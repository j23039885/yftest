||||||||||
mabutofu_
Invisible

This is the start of the #annoucemmmmmentttttt channel. 
|||||||||| â€” 1/12/2023 10:00 PM
Image
|||||||||| â€” 1/12/2023 10:16 PM
Image
|||||||||| â€” 12/12/2023 9:13 PM
Number systems and conversion:
Number system: A system for representing numbers using a set of digits and a base.
Conversion: Changing a number from one system to another.

Fractional and non-fractional:

Non-fractional: Integers (whole numbers)
Fractional: Numbers with a decimal point representing parts of a whole
Conversion methods:

Decimal to binary: Divide the decimal number by 2, collecting the remainders as the binary digits.
Binary to decimal: Multiply each binary digit by its place value (2 raised to the power of its position) and sum them up.
Conversion between other bases: Similar principles apply using the specific base values.
2's complement:
A way to represent signed integers in binary by inverting all bits and adding 1 to the result for negative numbers. Allows efficient addition and subtraction operations.
Machine language vs. assembly language vs. high-level language:
Machine language: The lowest level, directly understood by the processor. Instructions consist of binary codes.
Assembly language: Human-readable representation of machine language with mnemonics and symbolic names.
High-level language: Further abstraction from machine language, focusing on problem-solving and human understandability. Requires compilation or interpretation.

Addressing modes:
Ways to specify the location of data in memory within an instruction.

Valid addressing modes:

Immediate: Operand is directly included in the instruction.
Direct: Memory address is directly stored in the instruction.
Register: Operand is located in a specific CPU register.
Indirect: Memory address is stored in another memory location.
Invalid addressing modes:

Modes that require more memory accesses than supported by the processor.
Modes that attempt to access restricted memory areas.
Microprocessor registers:
Hold temporary data and intermediate results used by the CPU. Specific registers have specific functions, such as accumulator (ACC) and program counter (PC).

Flag condition:
Special bits in the CPU that indicate the result of an operation, such as carry flag (C) for overflow, zero flag (Z) for zero result, and sign flag (N) for negative result.
CMP, ADD, NOT:
CMP: Compares two operands, setting the flag condition based on the result.
ADD: Adds two operands, storing the result and updating the flag condition.
NOT: Negates the value of an operand.

Logic operations affecting flags:
AND: Sets the C flag if both operands are 1.
OR: Sets the C flag if at least one operand is 1.
XOR: Sets the C flag if only one operand is 1.

Stack memory and instructions:
Stack memory: LIFO (Last-In-First-Out) data structure used for temporary storage and function calls.
PUSH: Stores the value of a register on the stack.
POP: Retrieves the top value from the stack and stores it in a register.

Page fault:
Occurs when the CPU tries to access a memory location not mapped to the current memory page. Requires the operating system to handle the page mapping.

Memory protection:
Mechanisms used to prevent unauthorized access to memory regions. Can be implemented using hardware or software techniques.

Interrupt-driven I/O:
Interrupts are signals that temporarily halt the CPU and force it to handle an external event, such as receiving input or responding to an error. This allows efficient handling of asynchronous events without continuously polling for them.
|||||||||| â€” 13/12/2023 1:46 PM
-Number systems and conversion (Chap 2) âœ… 
-Fractional and non-fractional (Chap 2) âœ… 
-Decimal to binary (Chap 2) âœ… 
-Machine language vs. assembly language vs. high-level language (Chap 1) âœ… 
-Addressing modes (Chap 4) âœ… 
-Flag condition (Chap 3) âœ… 
-CMP, ADD, NOT (Chap 5) âœ… 
-Logic operations affecting flags (AND/OR/XOR) (Chap 5) âœ… 
-Stack memory and instructions (Chap 5) âœ… 
-Page fault (Chap 6) âœ… 
-Memory protection (Chap 6)  âœ… 
-Interrupt-driven I/O (Chap 7) âœ… 
-all microprocessor (Chap 3) âœ… 


-4 structured question (page fault, interrupt driven i/o, number system, addressing modes) 
|||||||||| â€” 13/12/2023 3:38 PM
(2^n-1) - 1 ---> to check +ve limit
(-2^n-1) ---> to check -ve limit
|||||||||| â€” 13/12/2023 8:02 PM
Target
___
-Number systems and conversion (Chap 2)
-Fractional and non-fractional (Chap 2)
-Decimal to binary (Chap 2)
-Machine language vs. assembly language vs. high-level language (Chap 1)
-Addressing modes (Chap 4) 
-Flag condition (Chap 3) 
-CMP, ADD, NOT (Chap 5)
-Logic operations affecting flags (AND/OR/XOR) (Chap 5)
-Stack memory and instructions (Chap 5)
-Page fault (Chap 6)
-Interrupt-driven I/O (Chap 7) 
|||||||||| â€” 14/12/2023 10:36 AM
Image
|||||||||| â€” 3/12/2024 9:43 PM
hr@isj-technology.com
|||||||||| â€” 4/12/2024 8:10 PM
Final Exam Tips-DCS2104

SAS Programming Process
Column attributes for SAS Tables
Syntax errors
SAS Code
DATA Step and a PROC Step
SAS Interfaces
SAS Libraries
|||||||||| â€” 25/12/2024 11:09 PM
Image
|||||||||| â€” 20/1/2025 7:15 PM
Image
|||||||||| â€” 16/3/2025 3:36 PM
https://drive.google.com/drive/folders/1Zq-2Z9aAg0LSTkXB2MREFyIbvDnVl2tP?usp=drive_link
Google Drive: Sign-in
Access Google Drive with a Google account (for personal use) or Google Workspace account (for business use).
|||||||||| â€” 19/3/2025 2:02 PM
https://drive.google.com/file/d/1gmjNljp_5mlilWcCnNuzl2VSEZgQknfJ/view?usp=drive_link
Google Docs
COC.rar
|||||||||| â€” 2/4/2025 10:48 PM
ðŸ–•
https://discord.com/assets/8212eefd302ecd68.svg
|||||||||| â€” 11/4/2025 11:11 PM
Image
|||||||||| â€” 22/5/2025 3:42 PM
https://youtu.be/u7oB2cacGUU
YouTube
mabutofu
how it feels to play siege in 2025
Image
|||||||||| â€” 1/6/2025 10:55 PM
Image
Image
Image
|||||||||| â€” 3/6/2025 9:35 PM
Image
|||||||||| â€” 22/6/2025 10:36 AM
Image
|||||||||| â€” 12/7/2025 3:17 PM
Correlation Heatmap:
The correlation heatmap shows that blood pressure abnormality is more strongly linked to chronic health conditions like adrenal and thyroid disorders, chronic kidney disease, and high stress levels. On the other hand, alcohol consumption, age, BMI, and hemoglobin levels have weaker correlations, meaning they may not directly affect blood pressure as much.

Heat Plot Analysis:
The heat plot suggests that blood pressure issues become more likely when several risk factors are present at the same time. Stronger color intensity appears when values for adrenal disorders, BMI, and kidney disease are higher. This supports the idea that a combination of health issues can lead to higher chances of abnormal blood pressure.
Expand
message.txt
3 KB
|||||||||| â€” 12/7/2025 10:00 PM
Summary:
The model has an Average Squared Error (ASE) of 0.19 and uses about 1,700 observations. The most important variables are Chronic_kidney_disease and Adrenal_and_thyroid_disorders. The plots show that the model works fairly well, but not perfectly.

Recommendation:
Try removing variables that are not useful (with high p-values) to make the model simpler. You can also test other types of models, like non-linear ones, to improve accuracy. It may also help to look more closely at the errors to improve the fit.









Ask ChatGPT
The results show that chronic kidney disease and adrenal and thyroid disorders have the strongest effect on blood pressure abnormalities. Other factors like age, BMI, alcohol use, and hemoglobin levels have a weaker influence. The decision tree model gave the best performance, with a low error rate (ASE = 0.14) and clear results using fewer, more important variables. The neural network model had a higher error (ASE = 0.22) and did not fit the data well, possibly because it included too many less useful variables. Another model using about 1,700 observations had an error of 0.19. It also showed that kidney and thyroid conditions are important, but the model was only moderately accurate.
The results show that chronic kidney disease and adrenal and thyroid disorders have the strongest effect on blood pressure abnormalities. Other factors like age, BMI, alcohol use, and hemoglobin levels have a weaker influence. The decision tree model gave the best performance, with a low error rate (ASE = 0.14) and clear results using fewer, more important variables. Another model using about 1,700 observations had an error of 0.19 and also highlighted kidney and thyroid conditions as key predictors, though its performance was only moderate.
What the graph are used for:

Histogram

To look into the amount of people that have high level of haemogoblin



Heatmap

To look into the background of patient that has high blood pressure



Correlation

To relate the causes to the blood pressure abnormality



Decision Tree

To determine the chances of someone getting abnormal blood pressure



Linear Regression

To determine the chances of someone getting abnormal blood pressure, it also acts as a double confirm to decision trees.
âœ… What the Graphs Are Used For:

    Histogram
    To show the number of people with different levels of hemoglobin, and to see if many people have high or low levels.

    Heatmap
    To explore the health background of patients with abnormal blood pressure and identify patterns in related conditions.

    Correlation Plot
    To show how strongly each factor is related to blood pressure abnormality (positive or negative relationships).

    Decision Tree
    To predict the chances of a person having abnormal blood pressure based on key risk factors.

    Linear Regression
    To estimate how different factors affect the risk of blood pressure abnormality and support the findings from the decision tree. It helps confirm patterns using a simpler, mathematical approach.
|||||||||| â€” 9:32 PM
const express = require("express");
const cors = require("cors");
const sqlite3 = require("sqlite3").verbose();
const path = require("path");
const fs = require("fs");
const multer = require("multer");

//  Firebase imports
const { initializeApp } = require("firebase/app");
const { getFirestore, collection, addDoc } = require("firebase/firestore");

// Firebase config
const firebaseConfig = {
  [censored]
};

//  Init Firebase + Firestore
const firebaseApp = initializeApp(firebaseConfig);
const firestoreDb = getFirestore(firebaseApp);
const express = require("express");
const cors = require("cors");
const sqlite3 = require("sqlite3").verbose();
const path = require("path");
const fs = require("fs");
const multer = require("multer");

// âœ… Use Firebase Admin SDK (NOT client SDK)
const admin = require("firebase-admin");

// âœ… Load your service account key (make sure this path is correct)
const serviceAccount = require("./path/to/your/serviceKey.json");

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});

// âœ… Firestore reference (admin)
const firestoreDb = admin.firestore();

const app = express();
app.use(cors());
app.use(express.json());

// Example: Firestore add route (you can modify for your use)
app.post("/uploadOrder", async (req, res) => {
  try {
    const data = req.body;

    // Example Firestore write
    const docRef = await firestoreDb.collection("orders").add({
      ...data,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
    });

    res.status(200).json({ message: "Order uploaded", id: docRef.id });
  } catch (err) {
    console.error("Upload error:", err);
    res.status(500).json({ error: "Upload failed" });
  }
});
Node.js v22.16.0
    at node:internal/main/run_main_module:36:49
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:171:5)
    at wrapModuleLoad (node:internal/modules/cjs/loader:235:24)
    at TracingChannel.traceSync (node:diagnostics_channel:322:14)
    at Function._load (node:internal/modules/cjs/loader:1282:12)
    at Module.load (node:internal/modules/cjs/loader:1465:32)
    at Object..js (node:internal/modules/cjs/loader:1895:10)
    at Module._compile (node:internal/modules/cjs/loader:1704:20)
    at wrapSafe (node:internal/modules/cjs/loader:1662:18)
SyntaxError: Identifier 'app' has already been declared
      ^
const app = express();
/opt/render/project/src/server.js:44
node server.js
restaurant-api@1.0.0 start
==> Running 'npm start'
==> Common ways to troubleshoot your deploy: https://render.com/docs/troubleshooting-deploys
==> Exited with status 1
Node.js v22.16.0
    at node:internal/main/run_main_module:36:49
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:171:5)
    at wrapModuleLoad (node:internal/modules/cjs/loader:235:24)
    at TracingChannel.traceSync (node:diagnostics_channel:322:14)
    at Function._load (node:internal/modules/cjs/loader:1282:12)
    at Module.load (node:internal/modules/cjs/loader:1465:32)
    at Object..js (node:internal/modules/cjs/loader:1895:10)
    at Module._compile (node:internal/modules/cjs/loader:1704:20)
    at wrapSafe (node:internal/modules/cjs/loader:1662:18)
SyntaxError: Identifier 'app' has already been declared
      ^
const app = express();
/opt/render/project/src/server.js:44
node server.js
restaurant-api@1.0.0 start
Render
Troubleshooting Your Deploy
Diagnose and resolve common issues when deploying to Render.
Troubleshooting Your Deploy
==> Exited with status 1
Node.js v22.16.0
}
  requireStack: [ '/opt/render/project/src/server.js' ]
  code: 'MODULE_NOT_FOUND',
    at Module._compile (node:internal/modules/cjs/loader:1730:14) {
    at Object.<anonymous> (/opt/render/project/src/server.js:9:15)
    at require (node:internal/modules/helpers:135:16)
    at Module.require (node:internal/modules/cjs/loader:1487:12)
    at wrapModuleLoad (node:internal/modules/cjs/loader:235:24)
    at TracingChannel.traceSync (node:diagnostics_channel:322:14)
    at Function._load (node:internal/modules/cjs/loader:1211:37)
    at resolveForCJSWithHooks (node:internal/modules/cjs/loader:1062:22)
    at defaultResolveImpl (node:internal/modules/cjs/loader:1057:19)
    at Function._resolveFilename (node:internal/modules/cjs/loader:1401:15)
/opt/render/project/src/server.js
Require stack:
Error: Cannot find module 'firebase-admin'
  ^
  throw err;
node:internal/modules/cjs/loader:1404
|||||||||| â€” 9:45 PM
Cleared completed orders from SQLite after upload
âŒ Firestore upload error: addDoc is not defined
const express = require("express");
const cors = require("cors");
const sqlite3 = require("sqlite3").verbose();
const path = require("path");
const fs = require("fs");
const multer = require("multer");
Expand
message.txt
9 KB
const express = require("express");
const cors = require("cors");
const sqlite3 = require("sqlite3").verbose();
const path = require("path");
const fs = require("fs");
const multer = require("multer");
const admin = require("firebase-admin");

// ðŸ” Load Firebase service account
const serviceAccount = require("./serviceaccountkey.json");
admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});
const firestoreDb = admin.firestore();

const app = express();
app.use(cors());
app.use(express.json());

// âš™ï¸ Multer storage setup
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(__dirname, "uploads");
    if (!fs.existsSync(uploadDir)) fs.mkdirSync(uploadDir, { recursive: true });
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  },
});
const upload = multer({ storage });

// ðŸ”— Static middleware
app.use(express.static(path.join(__dirname, "public")));
app.use("/uploads", express.static(path.join(__dirname, "uploads")));

// ðŸ—ƒï¸ SQLite database setup
const db = new sqlite3.Database("./orders.db");
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS orders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      customerName TEXT NOT NULL,
      phoneNumber TEXT NOT NULL,
      numberOfPeople INTEGER DEFAULT 1,
      items TEXT NOT NULL,
      status TEXT DEFAULT 'pending',
      timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
      paymentProof TEXT,
      verified BOOLEAN DEFAULT 0
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS promotions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      title TEXT NOT NULL,
      description TEXT NOT NULL,
      imagePath TEXT NOT NULL,
      date TEXT NOT NULL,
      timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS menu (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      type TEXT NOT NULL,
      price REAL NOT NULL,
      imagePath TEXT,
      timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);
});

// ðŸ“¥ Submit new order
app.post("/api/orders", upload.single("paymentProof"), (req, res) => {
  const { customerName, phoneNumber, numberOfPeople, reservationTime } = req.body;
  const paymentProof = req.file;

  if (!customerName || !phoneNumber || !req.body.items) {
    return res.status(400).json({ error: "Missing required fields" });
  }

  try {
    const items = JSON.parse(req.body.items);
    const validItems = Array.isArray(items) &&
      items.every(item => item.name && typeof item.price === "number" && typeof item.quantity === "number");

    if (!validItems) return res.status(400).json({ error: "Invalid items format" });
    if (!paymentProof) return res.status(400).json({ error: "Payment proof is required" });

    const timestamp = reservationTime ? new Date(reservationTime).toISOString() : new Date().toISOString();
    const sql = `
      INSERT INTO orders (customerName, phoneNumber, numberOfPeople, items, paymentProof, timestamp)
      VALUES (?, ?, ?, ?, ?, ?)
    `;

... (155 lines left)
Collapse
message.txt
8 KB
ï»¿
const express = require("express");
const cors = require("cors");
const sqlite3 = require("sqlite3").verbose();
const path = require("path");
const fs = require("fs");
const multer = require("multer");
const admin = require("firebase-admin");

// ðŸ” Load Firebase service account
const serviceAccount = require("./serviceaccountkey.json");
admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});
const firestoreDb = admin.firestore();

const app = express();
app.use(cors());
app.use(express.json());

// âš™ï¸ Multer storage setup
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(__dirname, "uploads");
    if (!fs.existsSync(uploadDir)) fs.mkdirSync(uploadDir, { recursive: true });
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  },
});
const upload = multer({ storage });

// ðŸ”— Static middleware
app.use(express.static(path.join(__dirname, "public")));
app.use("/uploads", express.static(path.join(__dirname, "uploads")));

// ðŸ—ƒï¸ SQLite database setup
const db = new sqlite3.Database("./orders.db");
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS orders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      customerName TEXT NOT NULL,
      phoneNumber TEXT NOT NULL,
      numberOfPeople INTEGER DEFAULT 1,
      items TEXT NOT NULL,
      status TEXT DEFAULT 'pending',
      timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
      paymentProof TEXT,
      verified BOOLEAN DEFAULT 0
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS promotions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      title TEXT NOT NULL,
      description TEXT NOT NULL,
      imagePath TEXT NOT NULL,
      date TEXT NOT NULL,
      timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS menu (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      type TEXT NOT NULL,
      price REAL NOT NULL,
      imagePath TEXT,
      timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);
});

// ðŸ“¥ Submit new order
app.post("/api/orders", upload.single("paymentProof"), (req, res) => {
  const { customerName, phoneNumber, numberOfPeople, reservationTime } = req.body;
  const paymentProof = req.file;

  if (!customerName || !phoneNumber || !req.body.items) {
    return res.status(400).json({ error: "Missing required fields" });
  }

  try {
    const items = JSON.parse(req.body.items);
    const validItems = Array.isArray(items) &&
      items.every(item => item.name && typeof item.price === "number" && typeof item.quantity === "number");

    if (!validItems) return res.status(400).json({ error: "Invalid items format" });
    if (!paymentProof) return res.status(400).json({ error: "Payment proof is required" });

    const timestamp = reservationTime ? new Date(reservationTime).toISOString() : new Date().toISOString();
    const sql = `
      INSERT INTO orders (customerName, phoneNumber, numberOfPeople, items, paymentProof, timestamp)
      VALUES (?, ?, ?, ?, ?, ?)
    `;

    db.run(sql, [
      customerName,
      phoneNumber,
      numberOfPeople || 1,
      JSON.stringify(items),
      paymentProof.filename,
      timestamp
    ], function (err) {
      if (err) return res.status(500).json({ error: err.message });

      res.status(201).json({
        id: this.lastID,
        customerName,
        phoneNumber,
        numberOfPeople: numberOfPeople || 1,
        items,
        status: "pending",
        timestamp,
        paymentProofUrl: `/uploads/${paymentProof.filename}`,
        verified: false,
      });
    });
  } catch (err) {
    return res.status(400).json({ error: "Invalid items format" });
  }
});

// ðŸ“¦ Get all orders (sorted by status and timestamp)
app.get("/api/orders", (req, res) => {
  const sql = `SELECT * FROM orders ORDER BY 
    CASE 
      WHEN status = 'pending' THEN 1
      WHEN status = 'preparing' THEN 2
      WHEN status = 'ready' THEN 3
      WHEN status = 'completed' THEN 4
      ELSE 5
    END, 
    timestamp DESC`;

  db.all(sql, [], (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });

    const orders = rows.map(row => ({
      ...row,
      items: JSON.parse(row.items),
      paymentProofUrl: row.paymentProof
        ? `${req.protocol}://${req.get("host")}/uploads/${row.paymentProof}`
        : null,
    }));

    res.json(orders);
  });
});

// ðŸ” Update order status
app.put("/api/orders/:id/status", (req, res) => {
  const { id } = req.params;
  const { status } = req.body;

  if (!status || !["pending", "preparing", "ready", "completed"].includes(status)) {
    return res.status(400).json({ error: "Invalid status" });
  }

  db.run(`UPDATE orders SET status = ? WHERE id = ?`, [status, id], function (err) {
    if (err) return res.status(500).json({ error: err.message });
    if (this.changes === 0) return res.status(404).json({ error: "Order not found" });

    res.json({ success: true, message: `Order status updated to ${status}` });
  });
});

// âœ… Verify payment proof
app.put("/api/orders/:id/verify", (req, res) => {
  const { id } = req.params;
  const { verified } = req.body;

  if (typeof verified !== "boolean") {
    return res.status(400).json({ error: "Invalid verification status" });
  }

  const statusUpdate = verified ? ", status = 'preparing'" : "";
  const sql = `UPDATE orders SET verified = ? ${statusUpdate} WHERE id = ?`;

  db.run(sql, [verified ? 1 : 0, id], function (err) {
    if (err) return res.status(500).json({ error: err.message });
    if (this.changes === 0) return res.status(404).json({ error: "Order not found" });

    res.json({
      success: true,
      message: verified
        ? "Payment verified and order moved to preparing"
        : "Payment verification removed",
    });
  });
});

// ðŸ§¹ Delete completed orders
app.delete("/api/orders/completed", (req, res) => {
  db.run(`DELETE FROM orders WHERE status = 'completed'`, function (err) {
    if (err) return res.status(500).json({ error: err.message });
    res.json({ success: true, message: `${this.changes} completed orders deleted` });
  });
});

// â˜ï¸ Upload completed orders to Firestore
app.post("/api/upload-completed-orders", (req, res) => {
  const sql = "SELECT * FROM orders WHERE status = 'completed'";

  db.all(sql, async (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });
    if (!rows.length) return res.json({ success: true, message: "No completed orders to upload." });

    let uploadedCount = 0;

    for (const row of rows) {
      try {
        await firestoreDb.collection("completed_orders").add({
          customerName: row.customerName,
          phoneNumber: row.phoneNumber,
          numberOfPeople: row.numberOfPeople,
          items: JSON.parse(row.items),
          status: row.status,
          timestamp: row.timestamp,
          paymentProof: row.paymentProof || null,
          verified: Boolean(row.verified)
        });
        uploadedCount++;
      } catch (e) {
        console.error("âŒ Firestore upload error:", e.message);
      }
    }

    res.json({
      success: true,
      message: `âœ… Uploaded ${uploadedCount} completed orders to Firebase`
    });

    // ðŸ§¼ Optional: Clear uploaded orders
    db.run("DELETE FROM orders WHERE status='completed'", () =>
      console.log("ðŸ—‘ï¸ Cleared completed orders from SQLite after upload")
    );
  });
});

// ðŸŒ Root route
app.get("/", (req, res) => {
  res.send("API is running.");
});

// ðŸš€ Start server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`âœ… Server running on http://localhost:${PORT}`);
});
